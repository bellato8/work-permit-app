// ======================================================================
// File: src/hooks/useAuthzLive.tsx
// เวอร์ชัน: 2025-09-18 01:25 (Asia/Bangkok)
// หน้าที่: ดึงสิทธิ์สด (role/caps) ของผู้ใช้ แล้ว "รวมระเบียนซ้ำ" + "แมพชื่อสิทธิ์" ให้เป็นมาตรฐาน
// เชื่อม auth ผ่าน "อะแดปเตอร์": ../lib/auth
// หมายเหตุ:
// - เรียก listadmins แบบ POST + headers: x-api-key, x-requester-email
// - ถ้าอีเมลเดียวกันมีหลายระเบียน → เลือก role ที่ "แรงสุด" (superadmin > admin > อื่น ๆ)
//   และรวม caps ของทุกระเบียนเข้าด้วยกัน
// - แปลงชื่อสิทธิ์ (alias) ให้ตรงกับที่หน้า UI ใช้ เช่น approve -> approve_requests
// ======================================================================

import { useEffect, useMemo, useState } from "react";
import { getCurrentUser } from "../lib/auth";
import { can, canAny, canAll } from "../lib/hasCap";

type AdminRecord = {
  email?: string;
  emailLower?: string;
  role?: string | null;
  enabled?: boolean;
  caps?: string[] | Set<string> | Record<string, boolean> | null;
  [k: string]: any;
};

type State = {
  loading: boolean;
  error?: string | null;
  userEmail?: string | null;
  role?: string | null;
  caps?: Set<string>;
};

const LIST_URL = import.meta.env.VITE_LIST_ADMINS_URL as string | undefined;
const APPROVER_KEY = import.meta.env.VITE_APPROVER_KEY as string | undefined;

// ฟิลด์เมทาดาทาที่ "ไม่ใช่สิทธิ์"
const IGNORES = new Set([
  "email",
  "emailLower",
  "enabled",
  "createdAt",
  "createdBy",
  "updatedAt",
  "updatedBy",
  "uid",
  "source",
  "firstLoginAt",
  "lastLoginAt",
]);

// จัดอันดับ role เพื่อเลือกตัวที่ "แรงสุด"
function roleRank(r?: string | null) {
  const s = (r ?? "").toLowerCase().trim();
  if (s === "superadmin") return 3;
  if (s === "admin") return 2;
  if (s === "approver" || s === "reviewer") return 1;
  return 0;
}

function toLower(s?: string | null) {
  return (s ?? "").toLowerCase().trim();
}

// รวม caps จากระเบียนเดี่ยว
function capsFromRecord(rec?: AdminRecord | null): Set<string> {
  const out = new Set<string>();
  if (!rec) return out;

  // 1) จาก rec.caps (Array/Set/Record)
  const caps = rec.caps as any;
  if (Array.isArray(caps)) {
    caps.forEach((c) => c && out.add(String(c).toLowerCase().trim()));
  } else if (caps instanceof Set) {
    Array.from(caps).forEach((c) => c && out.add(String(c).toLowerCase().trim()));
  } else if (caps && typeof caps === "object") {
    for (const [k, v] of Object.entries(caps)) {
      if (v) out.add(k.toLowerCase().trim());
    }
  }

  // 2) ฟิลด์ boolean ตรง ๆ ในเอกสาร (approve, reject, viewAll, manageUsers, ...)
  for (const [k, v] of Object.entries(rec)) {
    if (typeof v === "boolean" && v === true && !IGNORES.has(k)) {
      out.add(k.toLowerCase().trim());
    }
  }

  return out;
}

// เพิ่มชื่อสิทธิ์มาตรฐานจาก "นามแฝง"
function applyAlias(inSet: Set<string>): Set<string> {
  const out = new Set<string>(inSet);
  const has = (k: string) => out.has(k);

  // helper: เพิ่มทั้งคำเป้าหมายโดยไม่ลบของเดิม
  const add = (k: string) => out.add(k);

  // กลุ่ม Approvals
  if (has("approve")) add("approve_requests");
  if (has("reject")) add("review_requests");

  // ผู้ใช้/ผู้ดูแล
  if (has("manageusers")) add("manage_users");

  // Reports / Logs
  if (has("audit_log")) add("view_logs");
  if (has("view_reports")) add("view_reports"); // คงเดิมอยู่แล้ว

  // Settings
  if (has("settings")) add("manage_settings");
  if (has("system_settings")) add("manage_settings");

  // Permits
  if (has("viewall")) add("view_permits");
  if (has("view_all")) add("view_permits");

  // ความเข้ากันได้: ถ้าบางที่ยิงเป็น snake/camel สลับกัน
  // (กรณีภายหลังอยากรองรับย้อนกลับก็เติมได้)
  return out;
}

// รวมระเบียนที่เป็นอีเมลเดียวกัน → เลือก role ที่แรงสุด + รวม caps ทั้งหมด
function mergeMyRecords(all: AdminRecord[], myEmailLower: string) {
  const mine = all.filter(
    (r) => toLower(r.emailLower) === myEmailLower || toLower(r.email) === myEmailLower
  );
  if (mine.length === 0) return null;

  // role ที่ดีที่สุด
  let bestRole: string | null = null;
  let bestRank = -1;

  // รวม caps ทั้งหมด
  const capUnion = new Set<string>();

  for (const rec of mine) {
    const r = (rec.role ?? "").toLowerCase().trim();
    const rr = roleRank(r);
    if (rr > bestRank) {
      bestRank = rr;
      bestRole = r || null;
    }
    // รวม caps
    const c = capsFromRecord(rec);
    c.forEach((x) => capUnion.add(x));
  }

  // ใช้ alias mapping เติมคีย์มาตรฐาน
  const finalCaps = applyAlias(capUnion);

  return { role: bestRole, caps: finalCaps };
}

async function fetchAdminsPOST(requesterEmail: string): Promise<AdminRecord[]> {
  if (!LIST_URL) throw new Error("Missing VITE_LIST_ADMINS_URL");
  if (!APPROVER_KEY) throw new Error("Missing VITE_APPROVER_KEY");

  const res = await fetch(LIST_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": APPROVER_KEY,
      "x-requester-email": requesterEmail,
    },
    body: JSON.stringify({ requester: requesterEmail }),
  });

  if (!res.ok) {
    let msg = `${res.status} ${res.statusText}`;
    try {
      const j = await res.json();
      if (j?.error) msg = j.error;
    } catch {}
    throw new Error(msg || "forbidden");
  }

  const json = await res.json();
  const arr =
    (Array.isArray(json) && json) ||
    (Array.isArray(json?.items) && json.items) ||
    (Array.isArray(json?.data?.items) && json.data.items) ||
    (Array.isArray(json?.admins) && json.admins) ||
    (Array.isArray(json?.data) && json.data) ||
    [];
  return arr as AdminRecord[];
}

export default function useAuthzLive(): State {
  const [st, setSt] = useState<State>({ loading: true });

  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        const user = await getCurrentUser();
        const email = user?.email || null;
        const emailLower = toLower(email);

        if (!email) {
          if (!alive) return;
          setSt({ loading: false, userEmail: null, role: null, caps: new Set() });
          return;
        }

        const all = await fetchAdminsPOST(email);
        const merged = mergeMyRecords(all, emailLower);

        if (!merged) {
          if (!alive) return;
          setSt({
            loading: false,
            userEmail: email,
            role: null,
            caps: new Set(),
            error: "not_admin",
          });
          return;
        }

        if (!alive) return;
        setSt({
          loading: false,
          userEmail: email,
          role: merged.role ?? null,
          caps: merged.caps ?? new Set(),
        });
      } catch (e: any) {
        if (!alive) return;
        setSt({
          loading: false,
          error: String(e?.message || e),
          userEmail: null,
          role: null,
          caps: new Set(),
        });
      }
    })();

    return () => {
      alive = false;
    };
  }, []);

  return useMemo(() => st, [st]);
}

// ช็อตคัตสำหรับ component อื่น (ถ้าต้องการ)
// หมายเหตุ: ถ้า role เป็น superadmin → can/canAny/canAll ใน ../lib/hasCap จะผ่านทุกกรณี
export const canUse = (st: State, cap: string) =>
  can({ role: st.role, caps: st.caps }, cap);
export const canUseAny = (st: State, list: string[]) =>
  canAny({ role: st.role, caps: st.caps }, list);
export const canUseAll = (st: State, list: string[]) =>
  canAll({ role: st.role, caps: st.caps }, list);
